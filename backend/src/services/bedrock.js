import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime';
import { v4 as uuid } from 'uuid';
import { config } from '../config.js';

// Use Bedrock Runtime (Claude via Bedrock) with AWS credentials from env.
const bedrockClient = new BedrockRuntimeClient({ 
  region: config.awsRegion,
  credentials: {
    accessKeyId: config.awsAccessKeyId,
    secretAccessKey: config.awsSecretAccessKey,
    sessionToken: config.awsSessionToken
  }
});

async function invokeClaude(messages, system, max_tokens = 1200, temperature = 0.2) {
  const body = {
    anthropic_version: 'bedrock-2023-05-31',
    max_tokens,
    temperature,
    system,
    messages,
  };
  const command = new InvokeModelCommand({
    modelId: config.bedrockModelId,
    contentType: 'application/json',
    accept: 'application/json',
    body: JSON.stringify(body),
  });
  const response = await bedrockClient.send(command);
  const raw = new TextDecoder('utf-8').decode(response.body);
  const parsed = JSON.parse(raw);
  let text = '';
  if (parsed?.content && Array.isArray(parsed.content)) {
    const textBlock = parsed.content.find((c) => c.type === 'text');
    text = textBlock?.text || '';
  }
  if (!text && parsed?.output_text) text = parsed.output_text;
  if (!text && parsed?.completion) text = parsed.completion;
  if (!text) text = typeof parsed === 'string' ? parsed : JSON.stringify(parsed);
  return text;
}

// Stub: call AWS Bedrock to parse NL prompt to structured workflow
export async function parsePromptToWorkflow(prompt) {
  try {
    const system = [
      'You convert a natural language workflow description into a strict JSON object with keys: id, name, sourcePrompt, steps[], integrations[], metadata{model}.',
      'Each step has: id, type (condition|action), and either expression or action+params.',
      'Return ONLY the JSON object with no extra text or markdown.',
    ].join(' ');
    const messages = [
      { role: 'user', content: [{ type: 'text', text: `PROMPT:\n${prompt}` }] },
    ];
    const completion = await invokeClaude(messages, 800, 0.2);
    let text = (completion || '').trim();
    const fence = text.match(/```json\n([\s\S]*?)```/i);
    if (fence) text = fence[1];
    const workflow = JSON.parse(text);
    if (!workflow.metadata) workflow.metadata = {};
    workflow.metadata.model = config.bedrockModelId;
    if (!workflow.id) workflow.id = uuid();
    if (!workflow.sourcePrompt) workflow.sourcePrompt = prompt;
    return workflow;
  } catch (err) {
    console.warn('[Bedrock Runtime] parse fallback:', err?.message || err);
  }

  // Fallback stub
  return {
    id: uuid(),
    name: 'Generated Workflow',
    sourcePrompt: prompt,
    steps: [
      { id: 's1', type: 'condition', expression: "ticket.priority == 'high'" },
      { id: 's2', type: 'action', action: 'notify_manager', params: { channel: 'email' } },
    ],
    integrations: ['superops'],
    metadata: { model: config.bedrockModelId },
  };
}

// Stub: call Bedrock code generation to output Python/Lambda code
export async function generateCodeForWorkflow(workflow) {
  try {
    const system = [
      'Generate a single, self-contained SuperOps code using Python 3.11 file from the workflow JSON the user provides.',
      'Return ONLY the Python code. Do not include explanations or Markdown fences.',
      'The handler function must be named `handler(event, context)`.',
      'Assume no external dependencies beyond Python stdlib.',
    ].join(' ');
    const messages = [
      { role: 'user', content: [{ type: 'text', text: `WORKFLOW JSON:\n${JSON.stringify(workflow, null, 2)}` }] },
    ];
    const completion = await invokeClaude(messages, system, 1800, 0.2);
    const codeText = (completion || '').trim();
    if (codeText) {
      console.log('Successfully calling Bedrock')
      // Return model reply directly as code (no fence stripping) per user's preference
      return { language: 'python', runtime: 'python3.11', code: codeText };
    }
  } catch (err) {
    console.warn('[Bedrock Runtime] generate fallback:', err?.message || err);
  }
  // Fallback code generation
  const code = `# Auto-generated by Bedrock model: ${config.bedrockModelId}
# Workflow: ${workflow.name}
import json
import requests

# SuperOps API Integration
class SuperOpsClient:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://api.superops.ai"
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
    
    def notify_manager(self, ticket_id, channel='email'):
        payload = {
            "ticketId": ticket_id,
            "channel": channel,
            "message": f"High priority ticket {ticket_id} requires attention"
        }
        response = requests.post(f"{self.base_url}/notifications", 
                               json=payload, headers=self.headers)
        return response.json()
    
    def create_ticket(self, title, description, priority='high'):
        payload = {
            "title": title,
            "description": description,
            "priority": priority,
            "category": "automation"
        }
        response = requests.post(f"{self.base_url}/tickets", 
                               json=payload, headers=self.headers)
        return response.json()

# Handler for AWS Lambda
def handler(event, context):
    ticket = event.get('ticket', {})
    api_key = event.get('superops_api_key', 'your-api-key')
    
    client = SuperOpsClient(api_key)
    
    if ticket.get('priority') == 'high':
        # Send notification for high priority tickets
        result = client.notify_manager(ticket.get('id'), channel='email')
        return {
            'statusCode': 200,
            'body': json.dumps({
                'action': 'notify_manager',
                'result': result,
                'ticket_id': ticket.get('id')
            })
        }
    
    return {
        'statusCode': 200,
        'body': json.dumps({'action': 'none'})
    }
`;
  return { language: 'python', runtime: 'python3.11', code };
}